# 项目初始化

## 跨域解决方案

- 跨域是浏览器为了安全作出的策略

- 浏览器请求必须遵循同源策略：协议域名端口号

  //必须是http  aaa.ccom 80

iframe跨域了解

### cors跨域

easy mock是开源跨域,利用他就可以

需要后端指定跨域。

Access-Control-Allow-Credentials:true  允许带信用凭证。

用户名:quanlaibahuang

密码：quanlaibahuang

- 需要服务端允许前端站点访问。
- 服务端设置，前端必须

```js
axios(url).then(res=>{})
```

### jsonp跨域

并没有发送请求，只是引入了个js脚本，通过callback参数去取到后台的内容

- 前端适配，后台配合
- ‘他是一个js代码，相当于访问一个接口，然后传入参数，他根据你传入的参数return 出内容

```js
import jsonp from 'jsonp'
jsonp(url,(err,res)=>{
	let result = res;
    this.data = result;
})
//通过jsonp访问不会有拦截。
```

### 开发环境接口代理

- 访问/a接口通过代理转发到/b，但是看起来好像发送到自己接口一样
- 前端修改，后端不动

vue.config.js是node

nodejs遵循commonjs规范

最终的响应头是这样的

```
http://localhost:8080/activity/...........
```

```js
module.exports = {
	devServer:{
		host:'localhost',
		port:8080,
		proxy:{
		//访问到https://www.imooc.com/activity/serviecetime时，就不需要加这些，只把/api后面转发
			'/api':{
				target:'https://www.imooc.com',
				changeOrigin:true,  //是否把主机头改为目标url地址
                pathRewrite:{
                    '/api':''  //他置空，开发时使用。
                }
			}
		}
	}
}
axios('/activity/serviecetime').then(res=>{})
```

## 接口梳理

**状态码**

```
{
	"status":0  //成功  10：未登录
}
```

## 目录结构

- api同一管理
- util公共方法
- storage处理存储，sessonstorage localstorage
- store
- router.js路由文件
- pages文件
  - home.vue :框架结构,主页面
  - index.vue: 首页
  - product.vue:产品栈
  - detail:产品详情
  - orderList.vue 订单
  - order.vue 订单核心路由
  - orderConfim.vue 订单确认
  - cart.vue 购物车
  - login.vue登录页面。
  - orderPay.vue订单支付页面
  - 跳转支付中转页面 alipay.vue
- component

## 技术栈插件依赖

```shell
npm install vue-lazyload element-ui node-sass sass-loader vue-awesome-swiper vue-axios vue-cookie --save-dev
```

## 路由封装

```
└─home =>redirect index
│  └─ index
│  └─ product:id
│  └─ detail:id
├─ cart
│  └─ logo.png
├─ order
│  └─ confirm
│  └─ list
│  └─ alipay
│  └─ pay
```

## Storage封装

### cookie、localStorage、sessionStorage区别

cookie和storage区别:

- 存储大小:Cookie 4k  、 Storage 5M，但是现在前端可能会把批量的报文存储，如果使用cookie存，不合适，而且cookie会发生到服务端
- 有效期: Cookie 设置Expires 过期事件，LocalStorage永久存储，sessionstorage存在内存。
- cookie会自动发送到服务器端,存储在内存，localStorage存在浏览器，sessionstorage存储内存
- 路径：Cookie有路径问题，比如只让/a生效，Storage存在域名下，比如www.baidu.co
- Cookie设置API很麻烦，Storage有清晰的setitem(key,value)

localStoragesessionStorage:

- 前者是本地存储，后者存在内存，会话关闭就清除

为什么要封装？

- storage本身有api,但是只是简单的k/v
- storage只存储字符串，需要人工转换json对象



## 接口错误拦截

- 统一报错
- 未登录统一拦截
- 请求值、返回值统一处理
- 表单时间戳统一请求：axios可以帮助我们做返回值拦截

## axios拦截

**get +params**

**post没有params**

**axios.all同时发送多个请求**

```
axios.defaults.baseURL = '/api';
axios.defaults.timeout = 8000;
```

**接口响应拦截**

```js
// 接口错误拦截
axios.interceptors.response.use(function (response) {
  let res = response.data;
  if (res.status == 0) {  //0代表成功
    return res.data
  }else if(res.status == 10){ //状态码是10表示未登录
    window.location.href = '/#/login';
  }else{  //否则
    alert(res.msg);
  }
})
```

## 接口环境变量配置

```js
module.exports = {
  devServer:{
    host:'localhost',
    port:8080,
    proxy:{
      '/api':{
        target:'http://mall-pre.springboot.cn',
        changeOrigin:true,
        pathRewrite:{
          '/api':''
        }
      }
    }
  },

  productionSourceMap:true,
  chainWebpack:(config)=>{
    config.plugins.delete('prefetch');
  }
}
```

## mock设置

- 本地创建json并加载

```
需要把default.URL去掉。
```

- mockjs拦截数据请求。

require是执行时加载；

```
const mock = false;
//mock开关
if(mock){
  //require这样是按需加载。
  require('./mock/api')
}

```

