{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{383:function(t,_,v){\"use strict\";v.r(_);var a=v(28),e=Object(a.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"输入一个url后，发送了什么？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#输入一个url后，发送了什么？\"}},[t._v(\"#\")]),t._v(\" 输入一个url后，发送了什么？\")]),t._v(\" \"),a(\"h1\",{attrs:{id:\"一、导航流程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、导航流程\"}},[t._v(\"#\")]),t._v(\" 一、导航流程\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_1-用户输入\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-用户输入\"}},[t._v(\"#\")]),t._v(\" 1.用户输入\")]),t._v(\" \"),a(\"p\",[t._v(\"用户输入关键字时，地址栏会判断输入的是搜索内容还是请求的url\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"如果是搜索内容，地址栏就会使用默认浏览器搜索引擎，来合成带来搜索关键字的URL\")]),t._v(\" \"),a(\"li\",[t._v(\"如果判断输入内容符合URL规则，比如输入的是www.baidu.com。地址栏就会根据规则，加上协议合成完整的url,如https://www.baidu.com\")])]),t._v(\" \"),a(\"p\",[t._v(\"当回车按下后，浏览器页面图片进入加载状态，但是页面并未被替换，需要等待提交文档阶段。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_2-url请求过程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-url请求过程\"}},[t._v(\"#\")]),t._v(\" 2.URL请求过程\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"浏览器端发起-http-请求流程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#浏览器端发起-http-请求流程\"}},[t._v(\"#\")]),t._v(\" 浏览器端发起 HTTP 请求流程\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"查询缓存\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#查询缓存\"}},[t._v(\"#\")]),t._v(\" 查询缓存\")]),t._v(\" \"),a(\"p\",[t._v(\"接下来进入页面资源请求过程。浏览器进程通过IPC（进程间通讯）把URL请求发送到网络进程。\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[t._v(\"网络进程会查找本地缓存是否缓存了该资源\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[t._v(\"如果资源未缓存，发起新请求\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"如果已缓存，检验是否满足条件，条件满足就提供给客户端，否则与服务器进行验证。\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"检验新鲜通常有两个HTTP头进行控制\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"Expires\\n\")])])]),a(\"p\",[t._v(\"和\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"Cache-Control\\n\")])])]),a(\"p\",[t._v(\"：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期\")]),t._v(\" \"),a(\"li\",[t._v(\"HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间\")])])])])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"缓存查找失败，就会进入网络请求过程。\")])])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"准备ip地址和端口-dns解析\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#准备ip地址和端口-dns解析\"}},[t._v(\"#\")]),t._v(\" 准备IP地址和端口-DNS解析\")]),t._v(\" \"),a(\"p\",[t._v(\"浏览器使用\"),a(\"strong\",[t._v(\"HTTP 协议作为应用层协议\")]),t._v(\"，用来封装请求的文本信息；并使用\"),a(\"strong\",[t._v(\"TCP/IP 作传输层协议\")]),t._v(\"将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说\"),a(\"strong\",[t._v(\"HTTP 的内容是通过 TCP 的传输数据阶段来实现的\")]),t._v(\"。而tcp连接的第一步是准备ip地址和端口号。因此浏览器会请求DNS返回域名对应的IP,并且提供了DNS数据缓存服务。端口号http默认80\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[t._v(\"浏览器缓存\")]),t._v(\" \"),a(\"li\",[t._v(\"本机缓存\")]),t._v(\" \"),a(\"li\",[t._v(\"hosts文件\")]),t._v(\" \"),a(\"li\",[t._v(\"路由器缓存\")]),t._v(\" \"),a(\"li\",[t._v(\"ISP DNS缓存\")]),t._v(\" \"),a(\"li\",[t._v(\"DNS递归查询（可能存在负载均衡导致每次IP不一样）\")]),t._v(\" \"),a(\"li\",[t._v(\".....本地---》根---》顶级---》权威（递归或者迭代）\")])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"tcp连接\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#tcp连接\"}},[t._v(\"#\")]),t._v(\" TCP连接\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[t._v(\"TCP请求\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[t._v(\"等待TCP队列，Chrome同一个域名同时最多只能建立 6 个 TCP 连接\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"建立TCP连接 三次握手目的：浏览器和客户端都需要知道自己能正常收发信息。\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[t._v(\"大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"客户端发送SYN包=1请求建立连接，Seq=X 我当前序列号,\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"服务器返回SYN包=1请求建立连接，ack=X+1期望序列号，Seq=Y服务器当前序列号，ACK = 1确认序号成立\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"客户端发送ack=Y+1期望序列号，seq =X+1，ACK=1 确认洗好成立\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"ACK 0 确认序号无效 1  确认序号成立（请求建立连接）\\nSYN 1 new connection 建立连接\\nFIN 1 close 关闭连接\\nRST 1 distory connection 当前连接异常\\nPSH 1 数据无需缓存直接给进程\\nURG 0 紧急指针无效 1 禁忌之中有效，这个包不需要排队，直接进入缓存\\n复制代码\\n\")])])])])])])])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"进入传输数据阶段\")])])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"发送http请求\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#发送http请求\"}},[t._v(\"#\")]),t._v(\" 发送http请求\")]),t._v(\" \"),a(\"p\",[t._v(\"浏览器构建\"),a(\"strong\",[t._v(\"请求行\")]),t._v(\"信息（如下所示），构建好后，浏览器准备发起网络请求。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"GET /index.html HTTP1.1\\n复制代码\\n\")])])]),a(\"p\",[t._v(\"首先浏览器会向服务器发送\"),a(\"strong\",[t._v(\"请求行\")]),t._v(\"，它包括了\"),a(\"strong\",[t._v(\"请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议\")]),t._v(\"。\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"get请求：直接在浏览器地址栏键入极客时间的域名（time.geekbang.org），这就是告诉服务器要 Get 它的首页资源。\")]),t._v(\" \"),a(\"li\",[t._v(\"post请求：它用于发送一些数据给服务器，比如登录一个网站，就需要通过 POST 方法把用户信息发送给服务器。如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过\"),a(\"strong\",[t._v(\"请求体\")]),t._v(\"来发送。\")])]),t._v(\" \"),a(\"p\",[t._v(\"在浏览器发送请求行命令之后，还要以\"),a(\"strong\",[t._v(\"请求头\")]),t._v(\"形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"服务器处理请求返回给浏览器\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#服务器处理请求返回给浏览器\"}},[t._v(\"#\")]),t._v(\" 服务器处理请求返回给浏览器\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_1-返回请求\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-返回请求\"}},[t._v(\"#\")]),t._v(\" 1.返回请求\")]),t._v(\" \"),a(\"p\",[t._v(\"服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。\")]),t._v(\" \"),a(\"p\",[t._v(\"通过工具软件 curl 来查看返回请求数据\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"curl -i  https://www.baidu.com/\\n复制代码\\n\")])])]),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584414541950\"}})]),t._v(\" \"),a(\"p\",[t._v(\"首先服务器会返回\"),a(\"strong\",[t._v(\"响应行\")]),t._v(\"，包括协议版本和状态码。\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"最常用的状态码是 200，表示处理成功；\")]),t._v(\" \"),a(\"li\",[t._v(\"如果没有找到页面，则会返回\"),a(\"strong\",[t._v(\"404\")]),t._v(\"。\")])]),t._v(\" \"),a(\"p\",[t._v(\"之后服务器也会随同响应向浏览器发送\"),a(\"strong\",[t._v(\"响应头\")]),t._v(\"。。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。\")]),t._v(\" \"),a(\"p\",[t._v(\"最后，服务器发送响应体的数据，通常包含HTML实体内容\")]),t._v(\" \"),a(\"h5\",{attrs:{id:\"_2-重定向\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-重定向\"}},[t._v(\"#\")]),t._v(\" 2.重定向\")]),t._v(\" \"),a(\"p\",[t._v(\"如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL,网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"HTTP1.1 301 Moved Permanently (转移 永久地)    响应行\\n\\nDate:Thu,09 Jan 2020 00:10:33 GMT\\t\\t\\t\\t响应头\\nContent-Type:text/html\\nContent-Length:178\\nConnection:keep-alive\\nLocation:https://www.czw.com/            -------\\x3eloaction字段\\nStrict-Transport-Security:max-age=15768000\\n复制代码\\n\")])])]),a(\"p\",[a(\"strong\",[t._v(\"在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求\")]),t._v(\"。\")]),t._v(\" \"),a(\"h5\",{attrs:{id:\"_3-断开连接\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-断开连接\"}},[t._v(\"#\")]),t._v(\" 3.断开连接\")]),t._v(\" \"),a(\"p\",[t._v(\"通常服务器返回数据完毕就断开连接，但是如果头信息中有\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"Connection:Keep-Alive \\n复制代码\\n\")])])]),a(\"p\",[t._v(\"则 TCP 连接在发送后将仍然保持打开状态，这样浏览器就能继续通过这个连接发送请求。\"),a(\"strong\",[t._v(\"省去下次请求建立连接所需要的时间，提升资源加载速度\")])]),t._v(\" \"),a(\"p\",[t._v(\"如果初始化了一个持久连接，，请求一大堆来自同一个web站点的图片，就可以复用该连接一直请求资源而不是再建立新连接。\")]),t._v(\" \"),a(\"h5\",{attrs:{id:\"_4-缓存\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-缓存\"}},[t._v(\"#\")]),t._v(\" 4.缓存\")]),t._v(\" \"),a(\"p\",[t._v(\"当服务器返回\"),a(\"strong\",[t._v(\"HTTP 响应头\")]),t._v(\"给浏览器时，浏览器是\"),a(\"strong\",[t._v(\"通过响应头中的 Cache-Control 字段来设置是否缓存该资源\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"Cache-Control:Max-age=2000\\n复制代码\\n\")])])]),a(\"p\",[t._v(\"在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。\")]),t._v(\" \"),a(\"p\",[t._v(\"但如果缓存过期了，浏览器则会继续发起网络请求，并且在\"),a(\"strong\",[t._v(\"HTTP 请求头\")]),t._v(\"中带上：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('If-None-Match:\"4f80f-13c-3a1xb12a\"\\n复制代码\\n')])])]),a(\"p\",[t._v(\"服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"如果没有更新，就返回 304 状态码,告诉浏览器这个缓存可以继续使用\")]),t._v(\" \"),a(\"li\",[t._v(\"如果资源有更新，服务器就直接返回最新资源给浏览器。\")])]),t._v(\" \"),a(\"p\",[t._v(\"这也是很多网页第二次秒开的原因。这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。\")]),t._v(\" \"),a(\"h5\",{attrs:{id:\"_5-保持登录状态\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-保持登录状态\"}},[t._v(\"#\")]),t._v(\" 5.保持登录状态\")]),t._v(\" \"),a(\"p\",[t._v(\"简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[t._v(\"POST 方法提交用户登录信息给服务器。\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"服务器生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"Set-Cookie: UID=czw1111;\\n复制代码\\n\")])])])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把\"),a(\"code\",[t._v(\"UID=czw1111\")]),t._v(\"保持到本地。\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"再次访问时，浏览器会在发请求前读取cookie的数据，并把数据写在请求头的cookie里，再把请求头发给浏览器\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"Cookie: UID=czw1111;\\n复制代码\\n\")])])])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"服务器查找请求头里面的“Cookie”字段信息，查找到Cookie: UID=czw1111;，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息\")])])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_2-响应类型处理\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-响应类型处理\"}},[t._v(\"#\")]),t._v(\" 2.响应类型处理\")]),t._v(\" \"),a(\"p\",[t._v(\"接收到后首先进行gzip解压缩，然后判断类型\")]),t._v(\" \"),a(\"p\",[t._v(\"浏览器如何区分响应的数据类型？\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"HTTP中的Content-Type 告诉浏览器服务器返回的响应体数据是什么类型\")]),t._v(\"，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('C:\\\\Users\\\\xxx>curl -i  https://www.baidu.com/\\nHTTP/1.1 200 OK\\nAccept-Ranges: bytes\\nCache-Control: private, no-cache, no-store, proxy-revalidate, no-transform\\nConnection: keep-alive\\nContent-Length: 2443\\nContent-Type: text/html\\nDate: Tue, 17 Mar 2020 03:08:11 GMT\\nEtag: \"588603eb-98b\"\\nLast-Modified: Mon, 23 Jan 2017 13:23:55 GMT\\nPragma: no-cache\\nServer: bfe/1.0.8.18\\nSet-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/\\n复制代码\\n')])])]),a(\"p\",[t._v(\"Content-Type 的值是 application/octet-stream，显示数据是\"),a(\"strong\",[t._v(\"字节流类型\")]),t._v(\"的，通常情况下，浏览器会按照\"),a(\"strong\",[t._v(\"下载类型\")]),t._v(\"来处理该请求。\")]),t._v(\" \"),a(\"p\",[t._v(\"Content-type 字段的值是 text/html，这就是告诉浏览器，服务器返回的数据是\"),a(\"strong\",[t._v(\"HTML 格式\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。\")]),t._v(\" \"),a(\"p\",[t._v(\"如果 Content-Type 字段的值被浏览器判断为\"),a(\"strong\",[t._v(\"下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束\")]),t._v(\"。但如果是\"),a(\"strong\",[t._v(\"HTML，那么浏览器则会继续进行导航流程\")]),t._v(\"。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_3-准备渲染进程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-准备渲染进程\"}},[t._v(\"#\")]),t._v(\" 3. 准备渲染进程\")]),t._v(\" \"),a(\"p\",[t._v(\"通常，打开一个新页面就会配套创建一个新的渲染进程。\")]),t._v(\" \"),a(\"p\",[t._v(\"但是同一站点下会在同一个渲染进程，例如下面的b站，这两个页面使用了一个进程ID；\")]),t._v(\" \"),a(\"p\",[t._v(\"因为协议都是 HTTPS，而且根域名也都是 bilibili.com。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584417667294\"}})]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584417561164\"}})]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"这个默认策略叫 process-per-site-instance。\")]),t._v(\" \"),a(\"p\",[t._v(\"如果从b站打开的页面是其他站点，比如从b站打开个学日语的广告，他们则是两个进程，进程id也会不同。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584417750659\"}})]),t._v(\" \"),a(\"p\",[t._v(\"总结来说，打开一个新页面采用的\"),a(\"strong\",[t._v(\"渲染进程策略\")])]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"打开新的页面都会使用单独的渲染进程；\")]),t._v(\" \"),a(\"li\",[t._v(\"如果从 A 页面打开 B 页面，且 A 和 B 都属于\"),a(\"strong\",[t._v(\"同一站点\")]),t._v(\"的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。\")])]),t._v(\" \"),a(\"p\",[t._v(\"渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_4-提交文档-响应体数据\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-提交文档-响应体数据\"}},[t._v(\"#\")]),t._v(\" 4. 提交文档(响应体数据)\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"浏览器进程发起“提交文档”的消息，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“\"),a(\"strong\",[t._v(\"管道\")]),t._v(\"”。\")]),t._v(\" \"),a(\"li\",[t._v(\"等文档数据传输完成之后，渲染进程会返回“\"),a(\"strong\",[t._v(\"确认提交\")]),t._v(\"”的消息给浏览器进程。\")]),t._v(\" \"),a(\"li\",[t._v(\"浏览器进程在收到“确认提交”的消息后，会\"),a(\"strong\",[t._v(\"更新浏览器界面状态\")]),t._v(\"，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。\")])]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584417964645\"}})]),t._v(\" \"),a(\"p\",[t._v(\"之后就要进入渲染阶段了。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_5-渲染阶段\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-渲染阶段\"}},[t._v(\"#\")]),t._v(\" 5. 渲染阶段\")]),t._v(\" \"),a(\"p\",[t._v(\"一旦文档被提交，渲染进程便开始页面解析和子资源加载了，关于这个阶段的完整过程，我会在下一篇文章中来专门介绍。这里你只需要先了解一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。\")]),t._v(\" \"),a(\"h1\",{attrs:{id:\"二、渲染流程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、渲染流程\"}},[t._v(\"#\")]),t._v(\" 二、渲染流程\")]),t._v(\" \"),a(\"p\",[t._v(\"渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做\"),a(\"strong\",[t._v(\"渲染流水线\")]),t._v(\"，其大致流程如下图所示：\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584421712604\"}})]),t._v(\" \"),a(\"p\",[t._v(\"按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。内容比较多，我会用两篇文章来为你详细讲解这各个子阶段。接下来，在介绍每个阶段的过程中，你应该重点关注以下三点内容：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"开始每个子阶段都有其\"),a(\"strong\",[t._v(\"输入的内容\")]),t._v(\"；\")]),t._v(\" \"),a(\"li\",[t._v(\"然后每个子阶段有其\"),a(\"strong\",[t._v(\"处理过程\")]),t._v(\"；\")]),t._v(\" \"),a(\"li\",[t._v(\"最终每个子阶段会生成\"),a(\"strong\",[t._v(\"输出内容\")]),t._v(\"。\")])]),t._v(\" \"),a(\"p\",[t._v(\"理解了这三部分内容，能让你更加清晰地理解每个子阶段。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_1-构建-dom-树\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-构建-dom-树\"}},[t._v(\"#\")]),t._v(\" 1.构建 DOM 树\")]),t._v(\" \"),a(\"p\",[t._v(\"浏览器无法直接使用HTML，需要把HTML转化为浏览器可以理解的DOM树结构。\")]),t._v(\" \"),a(\"p\",[t._v(\"DOM树构建过程：\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584421994069\"}})]),t._v(\" \"),a(\"p\",[t._v(\"构建 DOM 树的\"),a(\"strong\",[t._v(\"输入内容\")]),t._v(\"是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。\")]),t._v(\" \"),a(\"p\",[t._v(\"在控制台输入document就可查看DOM树结构\")]),t._v(\" \"),a(\"p\",[t._v(\"和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('document.getElementsByTagName(\"p\")[0].innerText = \"black\"  修改DOM树内容\\n复制代码\\n')])])]),a(\"p\",[t._v(\"DOM树构建完毕后就进入节点样式计算\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_2-样式计算\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-样式计算\"}},[t._v(\"#\")]),t._v(\" 2.样式计算\")]),t._v(\" \"),a(\"p\",[t._v(\"样式计算（Recalculate Style）目的是为了计算出 DOM 节点中每个元素的具体样式\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_1-把-css-转换为浏览器能够理解的结构\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-把-css-转换为浏览器能够理解的结构\"}},[t._v(\"#\")]),t._v(\" 1.把 CSS 转换为浏览器能够理解的结构\")]),t._v(\" \"),a(\"p\",[t._v(\"CSS 样式来源主要有三种：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"通过 link 引用的外部 CSS 文件\")]),t._v(\" \"),a(\"li\",[a(\"code\",[t._v(\"<style>\")]),t._v(\"标记内的 CSS\")]),t._v(\" \"),a(\"li\",[t._v(\"元素的 style 属性内嵌的 CSS\")])]),t._v(\" \"),a(\"p\",[t._v(\"浏览器无法直接理解纯文本css,所以\"),a(\"strong\",[t._v(\"当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets\")]),t._v(\"。并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。\")]),t._v(\" \"),a(\"p\",[t._v(\"控制台输入\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"document.styleSheets \\n复制代码\\n\")])])]),a(\"p\",[t._v(\"这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_2-转换样式表中的属性值，使其标准化\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-转换样式表中的属性值，使其标准化\"}},[t._v(\"#\")]),t._v(\" 2. 转换样式表中的属性值，使其标准化\")]),t._v(\" \"),a(\"p\",[t._v(\"CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以\"),a(\"strong\",[t._v(\"需要将所有值转换为渲染引擎容易理解的、标准化的计算值\")])]),t._v(\" \"),a(\"p\",[t._v(\"比如2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700等等。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_3-计算出-dom-树中每个节点的具体样式\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-计算出-dom-树中每个节点的具体样式\"}},[t._v(\"#\")]),t._v(\" 3. 计算出 DOM 树中每个节点的具体样式\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"这就涉及到 CSS 的继承规则和层叠规则(权重值，是否脱离文档流，z-index等等)了。\")])]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"CSS 继承就是每个 DOM 节点都包含有父节点的样式\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。\")]),t._v(\" \"),a(\"p\",[t._v(\"Chrome 的“开发者工具”，选择第一个“element”标签，再选择“style”子标签\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584422506173\"}})]),t._v(\" \"),a(\"p\",[t._v(\"样式计算过程中，会根据 DOM 节点的继承关系来合理计算节点样式。\")]),t._v(\" \"),a(\"p\",[t._v(\"样式计算过程中的第二个规则是样式层叠，\"),a(\"strong\",[t._v(\"层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点\")])]),t._v(\" \"),a(\"p\",[t._v(\"样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584422641755\"}})]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"css加载会阻塞DOM树的解析和渲染吗？\")])]),t._v(\" \"),a(\"p\",[t._v(\"\\\\1. css加载不会阻塞DOM树的解析\")]),t._v(\" \"),a(\"p\",[t._v(\"\\\\2. css加载会阻塞DOM树的渲染\")]),t._v(\" \"),a(\"p\",[t._v(\"\\\\3. css加载会阻塞后面js语句的执行，因此会阻塞\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"提高css加载速度\")])]),t._v(\" \"),a(\"p\",[t._v(\"1.使用CDN\")]),t._v(\" \"),a(\"p\",[t._v(\"2.对css进行压缩\")]),t._v(\" \"),a(\"p\",[t._v(\"3.合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的\")]),t._v(\" \"),a(\"p\",[t._v(\"4.减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式，内联样式(把css代码直接写在现有的HTML标签中)的一个缺点就是不能缓存。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_3-布局阶段\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-布局阶段\"}},[t._v(\"#\")]),t._v(\" 3.布局阶段\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局\")]),t._v(\"。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_1-创建布局树\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-创建布局树\"}},[t._v(\"#\")]),t._v(\" 1. 创建布局树\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"只包含可见元素布局树\")]),t._v(\"。\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；\")]),t._v(\" \"),a(\"li\",[t._v(\"而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。\")])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_2-布局计算\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-布局计算\"}},[t._v(\"#\")]),t._v(\" 2. 布局计算\")]),t._v(\" \"),a(\"p\",[t._v(\"在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_4-分层\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-分层\"}},[t._v(\"#\")]),t._v(\" 4.分层\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"元素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。\")])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"什么是分层\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是分层\"}},[t._v(\"#\")]),t._v(\" 什么是分层\")]),t._v(\" \"),a(\"p\",[t._v(\"页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，\"),a(\"strong\",[t._v(\"渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树\")]),t._v(\"（LayerTree）。\")]),t._v(\" \"),a(\"p\",[t._v(\"Chrome 的“开发者工具”，选择“Layers”\")]),t._v(\" \"),a(\"p\",[t._v(\"渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584423442613\"}})]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584423461312\"}})]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"通常并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"创建新层的条件\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#创建新层的条件\"}},[t._v(\"#\")]),t._v(\" 创建新层的条件\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"第一点，拥有层叠上下文属性的元素会被提升为单独的一层。\")])]),t._v(\" \"),a(\"p\",[t._v(\"层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584423715992\"}})]),t._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"层叠上下文属性--MDN\"),a(\"OutboundLink\")],1),t._v(\"。\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"第二点，需要剪裁（clip）的地方也会被创建为图层。\")])]),t._v(\" \"),a(\"p\",[t._v(\"div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584423950160\"}})]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"<style>\\n      div {\\n            width: 200;\\n            height: 200;\\n            overflow:auto;\\n            background: gray;\\n        } \\n</style>\\n<body>\\n    <div >\\n        <p> 所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：</p>\\n        <p> 从上图我们可以看到，document 层上有 A 和 B 层，而 B 层之上又有两个图层。这些图层组织在一起也是一颗树状结构。</p>\\n        <p> 图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。</p> \\n    </div>\\n</body>\\n复制代码\\n\")])])]),a(\"p\",[a(\"a\",{attrs:{href:\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"overflow-MDN\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"p\",[t._v(\"此时,渲染引擎会为文字部分单独创建一个层,如果出现滚动条，滚动条也会被提升为单独的层\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_5-图层绘制\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-图层绘制\"}},[t._v(\"#\")]),t._v(\" 5.图层绘制\")]),t._v(\" \"),a(\"p\",[t._v(\"完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制,\")]),t._v(\" \"),a(\"p\",[t._v(\"渲染引擎把一个图层的绘制拆分成很多小的\"),a(\"strong\",[t._v(\"绘制指令\")]),t._v(\",再把这些指令按照顺序组成一个待绘制列表\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:v(!function(){var t=new Error(\"Cannot find module './'\");throw t.code=\"MODULE_NOT_FOUND\",t}()),alt:\"1584424164974\"}})]),t._v(\" \"),a(\"p\",[t._v(\"绘制列表的指令其实非常简单,就是执行一个简单的绘制操作,，比如绘制粉色矩形或者黑色的线等。\")]),t._v(\" \"),a(\"p\",[t._v(\"绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。\")])])}),[],!1,null,null,null);_.default=e.exports}}]);","extractedComments":[]}