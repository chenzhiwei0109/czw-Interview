# 手写源码

## 手写instanceof

instanceof:A沿着原型链能找到B.prototype。说明A instanceof B

按照链表的方式写就很简单了。遍历链表然后判断相等。

```js
function _instanceof(A,B){
  var p = A;
  while(p){
    if(p===B.prototype){
      return true
    }
    p =p.__proto__  //Object.getPrototypeOf(p)
  }
  return false
}
```

## 手写new运算符

- 创建一个对象obj指向构造函数的原型
- 构造函数call向obj
- 如果构造函数返回引用类型

```js
function _new(Fn, ...rest) {
  let obj = Object.create(Fn.prototype);
  let result = Fn.call(obj, ...rest);
  return result instanceof Object ? result : obj
}
```

```js
function _new(){
  const obj = new Object();
  const Constructor = [].shift.call(arguments); 
  obj.__proto__ = Constructor.prototype; 
  const ret = Constructor.apply(obj, arguments); 
  return typeof ret === "object" ? ret : obj;
}
```

## 手写create方法

**Object.create()**方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。

>创建构造函数，把构造函数原型指向现有对象，返回构造函数的实例化对象

```js
function create(proto){
  function F() {}
  F.prototype = proto;
  return new F();
}
```

```js
var ArrayPhoto = Object.create(Array.prototype)  
ArrayPhoto.__proto__ === Array.prototype  //true
var o = Object.create({}, { p: { value: 42 } })
```

## 手写isNaN

先验证是否是数字，然后基于Number()转换成数字类型。

```JS
function isNaN(i){
    let result = Number(i);
    return result !== result
}
```

## 手写call

- 将函数设为对象的属性 

- 执行&删除这个函数 

- 指定 this 到函数并传入给定参数执行函数 

- 如果不传入参数，默认指向为 window 

```js
Function.prototype._call = fuction(context=wi
                            ndow,...rest){
  context.fn = this;//this就是函数。
  const result = context.fn(...rest);//
  delete context.fn;
  return result
}
var obj = {
  name:1
}
function add(x,y){
  console.log(this.name)
  console.log(x,y)
}
add._call(obj,1,2);
```

## 手写apply

```js
Function.prototype._apply = fuction(context=window){
  context.fn = this;//this就是函数。
  let result;
  if(arguements[1]){
    result = context.fn(...arguements[1])
  }else{
    result = context.fn()
  }
  delete context.fn;
  return result
}
```

## 手写bind方法

```js
function myBind(context=window,...outerArg){
  let self = this
  return function(...innerArg){
    self.call(context,...outerArg.concat(innerArg))
  }
}
```

## 手写reduce

- reduce会对每个元素执行一个函数，最后把结果汇总成一个返回值。

- ```js
  arr.reduce(callback(sum, item[, index[, array]])[, initialValue])
  ```

```js
Array.prototype._reduce = function(cb,init){
  let accumu = init?init:this[0]
  for(let index = init?0:1;index<this.length;index++){
    accumu = cb(accumu,this[index],index,this)
  } 
  return accumu
}
```

## 手写trim

```js
String.prototype._trim = function(){
	return this.replace(/^\s+/,'').replace(/\s+$/,'')
}
```

## 手写event

## Object.freeze原理

- 对属性描述符设置false

## ajax

```js
//创建 XMLHttpRequest 对象
var xmlhttp;
if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
    xmlhttp = new XMLHttpRequest();
} else { // code for IE6, IE5
    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
}
// 向服务器发送请求  请求方式  url 是否异步
xmlhttp.open("GET", "test1.txt?name=zs", true);
xmlhttp.send();

// post  请求方式  url  是否异步
xmlhttp.open("POST","ajax_test.asp",true);
xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
xmlhttp.send("fname=Bill&lname=Gates");

// 服务器响应
xmlhttp.onreadystatechange = function () {
    if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
        console.log(xmlhttp.responseText);
    }
}
/*

        存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。

        0: 请求未初始化
        1: 服务器连接已建立
        2: 请求已接收
        3: 请求处理中
        4: 请求已完成，且响应已就绪
        */

/* 
            status
            200   (“OK”)  成功 一切正常
            500   服务期方面的问题
            503 （服务不可用）
            404   找不到资源
            301  永久重定向
            302  临时重定向
            304  缓存
        */

```



## promise

1.对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态：*pending*(进行中)、*fulfilled*(已成功)和*rejected*(已失败)。只有异步操作结果可以决定当前是哪个状态。任何其他操作都无法改变这个状态，如果没有异步操作，则一直处于*pending*状态



