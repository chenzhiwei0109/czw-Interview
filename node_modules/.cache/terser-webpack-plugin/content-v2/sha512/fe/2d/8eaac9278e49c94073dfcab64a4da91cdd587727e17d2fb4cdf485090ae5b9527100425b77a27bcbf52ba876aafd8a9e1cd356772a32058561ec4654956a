{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{1014:function(e,v,_){\"use strict\";_.r(v);var r=_(43),s=Object(r.a)({},(function(){var e=this,v=e.$createElement,r=e._self._c||v;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"promise原理解析与实现\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise原理解析与实现\"}},[e._v(\"#\")]),e._v(\" Promise原理解析与实现\")]),e._v(\" \"),r(\"p\",[e._v(\"[TOC]\")]),e._v(\" \"),r(\"p\",[r(\"code\",[e._v(\"Promise\")]),e._v(\" 是 \"),r(\"code\",[e._v(\"JavaScript\")]),e._v(\" 异步编程的一种流行解决方案，掌握 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 的使用是我们不可或缺的一项基本技能。但是要想熟练掌握并深入的理解它，还是必须要知道它的实现原理的。这节课就是从具体使用角度出发，使用原生手写方式一步一步的带你实现 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 库，而且不仅仅只是包含了 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 目前通用的功能，还有 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 的一些新的特性和未来即将支持的特性的介绍与实现\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"promise-类\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-类\"}},[e._v(\"#\")]),e._v(\" Promise 类\")]),e._v(\" \"),r(\"p\",[r(\"code\",[e._v(\"Promise\")]),e._v(\" 的构造函数必须接收一个函数参数（也就是需要执行异步任务的函数），该函数将在传入以后立即调用，并传入 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象下的两个方法 \"),r(\"code\",[e._v(\"resolve\")]),e._v(\" 和 \"),r(\"code\",[e._v(\"reject\")])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"promise-状态\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-状态\"}},[e._v(\"#\")]),e._v(\" Promise 状态\")]),e._v(\" \"),r(\"p\",[e._v(\"每一个 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象都存在以下三种状态：\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"PENDING : 进行中，\"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象的初始状态\")]),e._v(\" \"),r(\"li\",[e._v(\"FULFILLED : 已成功\")]),e._v(\" \"),r(\"li\",[e._v(\"REJECTED : 已失败\")])]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"每一个 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象只能由 \"),r(\"code\",[e._v(\"PENDING\")]),e._v(\" 状态变成 \"),r(\"code\",[e._v(\"FULFILLED\")]),e._v(\" 或 \"),r(\"code\",[e._v(\"REJECTED\")]),e._v(\"，且状态发生变化以后就能再改变了 ---- 记住这个特性\")])]),e._v(\" \"),r(\"p\",[e._v(\"一个 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象状态的变化并不由 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象本身来决定，而应该是由我们传入的异步任务完成情况来决定的，\"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 提供了两个用来改变状态的方法\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"promise-resolve-方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-resolve-方法\"}},[e._v(\"#\")]),e._v(\" promise.resolve 方法\")]),e._v(\" \"),r(\"p\",[e._v(\"将 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象的状态从 \"),r(\"code\",[e._v(\"PENDING\")]),e._v(\" 变为 \"),r(\"code\",[e._v(\"FULFILLED\")]),e._v(\"，并执行成功后的注册任务\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"注意：如果当前状态已经改变过了，则直接 \"),r(\"code\",[e._v(\"return\")])])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"promise-reject-方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-reject-方法\"}},[e._v(\"#\")]),e._v(\" promise.reject 方法\")]),e._v(\" \"),r(\"p\",[e._v(\"将 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象的状态从 \"),r(\"code\",[e._v(\"PENDING\")]),e._v(\" 变为 \"),r(\"code\",[e._v(\"REJECTED\")]),e._v(\"，并执行失败后的注册任务\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"注意：如果当前状态已经改变过了，则直接 \"),r(\"code\",[e._v(\"return\")])])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"promise-then-方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-then-方法\"}},[e._v(\"#\")]),e._v(\" promise.then 方法\")]),e._v(\" \"),r(\"p\",[r(\"code\",[e._v(\"then\")]),e._v(\" 是 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象提供的一个方法，它接收两个函数作为参数，分别注册到 \"),r(\"code\",[e._v(\"resolve\")]),e._v(\" 和 \"),r(\"code\",[e._v(\"reject\")]),e._v(\"  方法执行后的任务队列中，我们需要在 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 中维护两个队列\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"fulfilledQueues\")]),e._v(\" \"),r(\"li\",[e._v(\"rejectedQueues\")])]),e._v(\" \"),r(\"h3\",{attrs:{id:\"添加任务\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#添加任务\"}},[e._v(\"#\")]),e._v(\" 添加任务\")]),e._v(\" \"),r(\"p\",[e._v(\"把 \"),r(\"code\",[e._v(\"then\")]),e._v(\" 方法中接收到的两个函数分别添加到对应的任务队列中\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"执行任务\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#执行任务\"}},[e._v(\"#\")]),e._v(\" 执行任务\")]),e._v(\" \"),r(\"p\",[e._v(\"在 \"),r(\"code\",[e._v(\"Promise.resolve\")]),e._v(\" 和 \"),r(\"code\",[e._v(\"Promise.reject\")]),e._v(\" 方法中调用执行对应的任务队列的所有注册函数\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"宏任务-微任务\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#宏任务-微任务\"}},[e._v(\"#\")]),e._v(\" 宏任务 & 微任务\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:_(568),alt:\"image-20190902175947399\"}})]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:_(569),alt:\"image-20190902175947399\"}})]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"异步任务\\n\"),r(\"ul\",[r(\"li\",[e._v(\"微任务\")]),e._v(\" \"),r(\"li\",[e._v(\"宏任务\")])])])]),e._v(\" \"),r(\"p\",[r(\"code\",[e._v(\"then\")]),e._v(\" 方法是一个微任务\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"setTimeout(fn, 0);\")]),e._v(\" \"),r(\"li\",[e._v(\"postMessage\")]),e._v(\" \"),r(\"li\",[e._v(\"MutationObserver\")])]),e._v(\" \"),r(\"h3\",{attrs:{id:\"结果传递\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#结果传递\"}},[e._v(\"#\")]),e._v(\" 结果传递\")]),e._v(\" \"),r(\"p\",[e._v(\"在调用 \"),r(\"code\",[e._v(\"reslove\")]),e._v(\" 或者 \"),r(\"code\",[e._v(\"reject\")]),e._v(\" 方法的时候，我们还可以通过传入一些值，在后续的 \"),r(\"code\",[e._v(\"then\")]),e._v(\" 方法中，可以通过对应的函数接收到该结果\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"如果在一个 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象的状态改变后调用\"),r(\"code\",[e._v(\"then\")]),e._v(\" 则会立即执行添加的对应函数，所以需要注意必须根据当前 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 的状态来做不同的处理\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"PENDING : 添加到对应的任务队列\")]),e._v(\" \"),r(\"li\",[e._v(\"FULFILLED / REJECTED : 不用添加到队列，而是立即执行任务\")])])]),e._v(\" \"),r(\"h3\",{attrs:{id:\"返回值\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#返回值\"}},[e._v(\"#\")]),e._v(\" 返回值\")]),e._v(\" \"),r(\"p\",[r(\"code\",[e._v(\"then\")]),e._v(\" 方法在执行最后必须返回一个新的 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[r(\"span\",{staticStyle:{color:\"red\"}},[e._v(\"重点（难点）\")])]),e._v(\" \"),r(\"p\",[e._v(\"返回 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\"对象会立即调用并执行，如果这个时候，直接去执行该对象的 \"),r(\"code\",[e._v(\"resolve\")]),e._v(\" 或者 \"),r(\"code\",[e._v(\"reject\")]),e._v(\" 方法都会导致后续的 \"),r(\"code\",[e._v(\"then\")]),e._v(\" 也立即被调用\")]),e._v(\" \"),r(\"p\",[e._v(\"我们需要对原 \"),r(\"code\",[e._v(\"fulfilledHandler\")]),e._v(\" 和 \"),r(\"code\",[e._v(\"rejectedHandler\")]),e._v(\" 进行包装，把它们和新 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象的 \"),r(\"code\",[e._v(\"resolve\")]),e._v(\" 和 \"),r(\"code\",[e._v(\"reject\")]),e._v(\" 方法分别放置到新的函数中，并把这个新的函数添加到原有任务队列中调用\")]),e._v(\" \"),r(\"p\",[e._v(\"简而言之：把新返回的 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象的 \"),r(\"code\",[e._v(\"resolve\")]),e._v(\" 和 \"),r(\"code\",[e._v(\"reject\")]),e._v(\" 与 \"),r(\"code\",[e._v(\"then\")]),e._v(\" 中执行的 \"),r(\"code\",[e._v(\"fulfilledHandler\")]),e._v(\" 和 \"),r(\"code\",[e._v(\"rejectedHandler\")]),e._v(\" 添加到一个任务队列中执行，这样才能使用原有的 \"),r(\"code\",[e._v(\"then\")]),e._v(\" 执行完成以后才执行新的 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 中的 \"),r(\"code\",[e._v(\"then\")])])]),e._v(\" \"),r(\"p\",[e._v(\"上面是默认情况下的处理情况，其实 \"),r(\"code\",[e._v(\"then\")]),e._v(\" 方法的处理更为复杂\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"当一个\"),r(\"a\",{attrs:{href:\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\",target:\"_blank\",rel:\"noopener noreferrer\"}},[r(\"code\",[e._v(\"Promise\")]),r(\"OutboundLink\")],1),e._v(\"完成（fulfilled）或者失败（rejected），返回函数将被异步调用（由当前的线程循环来调度完成）。具体的返回值依据以下规则返回：\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"如果then中的回调函数没有返回值，那么then返回的Promise将会成为接受状态，并且该接受状态的回调函数的参数值为 undefined。\")]),e._v(\" \"),r(\"li\",[e._v(\"如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。\")]),e._v(\" \"),r(\"li\",[e._v(\"如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。\")]),e._v(\" \"),r(\"li\",[e._v(\"如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。\")]),e._v(\" \"),r(\"li\",[e._v(\"如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。\")]),e._v(\" \"),r(\"li\",[e._v(\"如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。\")])])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"promise-catch-方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-catch-方法\"}},[e._v(\"#\")]),e._v(\" promise.catch 方法\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"promise-finally-方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-finally-方法\"}},[e._v(\"#\")]),e._v(\" promise.finally 方法\")]),e._v(\" \"),r(\"p\",[r(\"u\",[e._v(\"ECMA2018 Added\")])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"promise-resolve-方法-2\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-resolve-方法-2\"}},[e._v(\"#\")]),e._v(\" Promise.resolve 方法\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"promise-reject-方法-2\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-reject-方法-2\"}},[e._v(\"#\")]),e._v(\" Promise.reject 方法\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"promise-all-方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-all-方法\"}},[e._v(\"#\")]),e._v(\" Promise.all 方法\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"promise-race-方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-race-方法\"}},[e._v(\"#\")]),e._v(\" Promise.race 方法\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"promise-allsettled-方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-allsettled-方法\"}},[e._v(\"#\")]),e._v(\" Promise.allSettled 方法\")]),e._v(\" \"),r(\"p\",[r(\"a\",{attrs:{href:\"https://tc39.es/proposal-promise-allSettled/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"（TC39第4阶段草案）\"),r(\"OutboundLink\")],1)]),e._v(\" \"),r(\"p\",[e._v(\"ECMA 2020 新增\")])])}),[],!1,null,null,null);v.default=s.exports},568:function(e,v,_){e.exports=_.p+\"assets/img/event-loop.2336375b.png\"},569:function(e,v,_){e.exports=_.p+\"assets/img/2.b5d6cb45.jpg\"}}]);","extractedComments":[]}