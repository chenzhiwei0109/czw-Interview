# 异步编程

## promise常用api

- Promise.prototype.then() then里的函数return出的东西就是下一个promise接收的。

- Promise.prototype.catch **catch可以捕获他之前的所有promise的错误。**

- Promise.prototype.finally  **es9,不管结果如何都会执行，本质是then方法的特例**

  ```js
  promise.finally(() => {});// 等同于
  promise.then(result =>{return result;},error =>{ throw error;});
  ```

- Promise.all([p1,p2,p3])  **接收一个具有Interator接口的参数。如果全部成功，会返回一个返回结果组成的数组，**

  ```js
  var promise1 = Promise.resolve(3);var promise2 = 42;
  var promise3 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 100, 'foo');
  });
  Promise.all([promise1, promise2, promise3]).then(function(values) {
    console.log(values);
  });
  // expected output: Array [3, 42, "foo"]
  ```

  

## promise常见问题

1. 如何改变promise状态？

   - resolve(value):如果当前是pending就变成resolved状态

   - reject(val):如果当前是pending就变为rejected

   - 抛出异常：如果当前是pending就变为rejected

     ```js
     new Promise(res,rej=>{
       throw new Error('出错')
     })
     ```

     

2. 一个promise指定多个成功/失败回调函数, 都会调用吗?

   - 当promise改变为对应状态时都会调用

     ```js
     let a = new Promise()
     a.then(...)
     a.then(...)
     ```

## promise并发限制

