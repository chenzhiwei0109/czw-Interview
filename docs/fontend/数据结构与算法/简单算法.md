---
sidebarDepth:2
---
# 简单算法
## 字符串类

### 翻转字符串单词

知识点:

- String.split
- match
- Array.map
- Array.reverse
- Array.join

<https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/>

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

**示例 1:**

```
输入: "Let's take LeetCode contest"
输出: "s'teL ekat edoCteeL tsetnoc" 
```

**注意：**在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。

#### **思路1**

- 字符串按照空格变成数组
- 每个单词翻转

```js
//尽量一行搞定！！
var reverseWords = function(s) {
	// spit (separator,howmany)  如果设置了howmany，返回的子串不会多于这个参数指定的数组
	let arr = s.split(' ');
    // map返回数组
    let result = arr.map((item)=>{
        return item.split('').reverse().join('')
    })
    return result.join(' ')
};
```

#### **思路2**

v-on思路

```js
var reverseWords = function(s) {
    //比map快，先翻转整个
    let arr=s.split("").reverse().join("")
    //再使用" "分割成数组并翻转，然后使用" "转换成字符串
    return arr.split(" ").reverse().join(" ")
};
```

#### **思路3**

```js
var reverseWords = function(s) {
    //匹配空格
	return str.split(/\s/g).map(item=>item.split('').reverse().join('')).join(' ')
};
```

**思路4**

```js
var reverseWords = function(s) {
    //匹配空格 [\w']可选的 空格或者' 一次
	return str.match(/[\w']+/g).map(item=>item.split('').reverse().join('')).join(' ')
};
```

### 计数二进制子串

给定一个字符串 `s`，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

**示例 1 :**

```
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
```

**示例 2 :**

```
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
```

**注意：**

- `s.length` 在1到50,000之间。
- `s` 只包含“0”或“1”字符。

#### **思路**

把0和1都分别放到数组里

"1001011"=>[1,00,1,0,11]=>从前往后两两对比，选择长度最短的

- 1.如果前者<=后者，个数=个数+前者，
- 2.如果前者>后者，个数=个数+后者

1和00对比,满足第一条， count = 0+1 =1

 00和1对比，满足第二条，count = 1+1 =2

1和0对比，满足第一条，count =  2+1 = 3

0和11对比，满足第一条，count = 3+1 = 4

```js
var countBinarySubstrings =function (s) {
    let count = 0;
    let list=[];
    let n=0;
	for(let i = 0;i<s.length-2;i++){
		if(s[i]!==s[i+1]){
            count ++;
            list.push(count);
            count = 0;
        }else{
            count ++;
        }
    }
    if(count = 0){
        list.push(1)
    }else{
        list[list.length-1] + =1
    }
    for (let i = 0; i < list.length - 1; i++) {
   	 	n += Math.min(list[i], list[i + 1])
  	}
    return n;
}
```

## 数组类

### 电话号码组合

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](../../.vuepress/public/assets/img/17_telephone_keypad.png)

**示例:**

```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

**说明:**
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

#### **方法1**

将前两组合后再将其结果与下一个进行组合
因此立即想到将前两个分出来，将其组成第一份数组

```js
var letterCombinations =  function(digits) {
	let map = ['',1,'abc','']

```



### 卡牌分组

### 种花问题

### 格雷编码	

