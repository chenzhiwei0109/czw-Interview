### 背景

1. Node在V8引擎之上构建，其模型与浏览器类似，js将会运行在单个进程的单个线程上；

- 好处：**程序状态是单一的，不存在多线程情况下的锁、线程同步的问题，操作系统在调度时因为较少上下文的切换，可以很好的提高cpu的使用率**；
- 缺点
  - 如今CPU基本是多核的，一个Node进程只能用一个核 -> **如何充分利用多核cpu服务器？**
  - Node执行在单线程上，一旦单线程上抛出的异常没有被捕获，将会引起整个进程的崩溃 -> **如何保证进程的健壮性核稳定性？**

1. Node并非真正的单线程架构，其自身还有一定的IO线程存在，这些IO线程由底层libuv处理，对js开发者是透明的，只在c++扩展开发时才会关注到 -> **js代码永远运行在V8上，是单线程的**。
    *注：*，由于**一个CPU核心在 一个时刻只能做一件事情**，操作系统只能通过**将CPU切分为时间片**的方法，让线程可以较为均匀地使用CPU资源，但是操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量过多时， 时间将会被耗用在上下文切换中。

### 多进程架构

1. **child_process模块**：支持Node随意创建子进程的能力；
    （1）创建异步子进程：返回一个ChildProcess实例，允许父进程注册监听器函数，在子进程生命周期期间，当特定事件发生时会调用这些函数；

- spawn(command[, args])：使用给定的command和args中的命令行参数衍生一个新进程；
- exec(command[, options][, callback(err, stdout, stderr)])：衍生一个shell并在shell中执行命令command，且缓冲任何产生的输出，有一个回调函数获知子进程的状况；
- execFile(file[, callback])：衍生出一个新进程来执行file(文件名/路径)；
- fork(modulePath)：衍生新的nodejs进程，每个进程都有自己的内存，使用自己的V8实例；

