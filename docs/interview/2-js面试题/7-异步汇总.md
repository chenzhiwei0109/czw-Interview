# 异步编程

## 1.ajax5个面试题

### ajax

- 创建XMLHttpRequest实例xhr
- 调用实例的open方法,open(method,url,true/false)
- 调用onreadystatechange监听状态变化
- 调用send方法发送请求，并把请求体传入

```js
let xhr = new XMLHttpRequest
xhr.open('get',url,true)
xhr.send(null)
xhr.onreadystatechange= ()=>{
    //readyState记录状态
    // 0实例创建 1调用open 2调用send,头部和状态获取 3下载中 4下载完成
    // xhr.status:http状态码 200成功 301永久 302临时 304走缓存 400 401 404 500 503
    if(xhr.readyState===4&&(xhr.status===200)){
        let result = xhr.responeText;
        console.log(result)
    }
}
```

**XMLHttpRequest.readyState** 属性返回一个 XMLHttpRequest 代理当前所处的状态。一个 XHR 代理总是处于下列状态中的一个：

| 值   | 状态               | 描述                                                |
| ---- | ------------------ | --------------------------------------------------- |
| `0`  | `UNSENT`           | 代理被创建，但尚未调用 open() 方法。                |
| `1`  | `OPENED`           | `open()` 方法已经被调用。                           |
| `2`  | `HEADERS_RECEIVED` | `send()` 方法已经被调用，并且头部和状态已经可获得。 |
| `3`  | `LOADING`          | 下载中； `responseText` 属性已经包含部分数据。      |
| `4`  | `DONE`             | 下载操作已完成。                                    |

- UNSENT

  XMLHttpRequest 代理已被创建， 但尚未调用 open() 方法。

- OPENED

  open() 方法已经被触发。在这个状态中，可以通过 [setRequestHeader()](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader) 方法来设置请求的头部， 可以调用 [send()](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send) 方法来发起请求。

- HEADERS_RECEIVED

  send() 方法已经被调用，响应头也已经被接收。

- LOADING

  响应体部分正在被接收。如果 `responseType` 属性是“text”或空字符串， `responseText` 将会在载入的过程中拥有部分响应数据。

- DONE

  请求操作已经完成。这意味着数据传输已经彻底完成或失败。

### ajax有几个方法

8个

### get和post区别

GET系列：get delete head options

POST系列：post put

在向服务器传递信息时，get基于URL的问号传参，post系列都是在请求体里.

>- get请求会被浏览器缓存（你在地址栏输入就能看见），post不会
>- get会有大小限制，post理论上没有限制
>- （记住）get在浏览器回退时没有影响，如果post请求，他可能会重复提交
>- 



1. （记住）get请求会被浏览器主动缓存（你在地址栏输入就能看见），post不会
2. （记住）get请求只能进行url编码，post支持多种编码方式
3. get请求参数会被完整保存在历史记录，post不会保存。防止csrf攻击，可以使用post。
4. （记住）get请求有长度限制，不同浏览器限制不一样，所以get请求的url不可以太长。否则会截断，post无限制。
5. get只接受ASCII字符，POST无限制
6. GET会暴露在URL上，不能传递敏感信息
7. （记住）GET参数放在url,地址栏能看见，POST放在请求体。

### 常见的状态码和区别

200 

301永久

302/307临时

304缓存

400参数错误

401没权限,token失效

404 没有这个页面

500 服务器错误，一般不会告诉前端服务器的错误。

503 超负荷

### 常见传输数据的格式

+ form-data 文件上传/表单提交

```js
let form1 = new FormData()
form1.append('lx',0)
xhr.send({
    form-data
})
```

- x-www-form-urlencoded 和问好参数一致

```js
xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')

xhr.send('a=0&b=1')
```

- raw 字符串 JSON/txt

```js
xhr.send(JSON.stingify({name:1,age:2}))

//mime application/json
xhr.setRequestHeader('Content-Type','application/json')
xhr.send(JSON.stingify({name:1,age:2}))
```

### $.ajax,axios,fetch区别

- $ajax和axios使用的XMLhttpRequest
  - axios使用的是promise,链式调用，不会有回调深渊
  - $ajax是jq封装的方法，使用回调方式。
- fetch不使用xmlhttprequest。和axios用法差不多。
  - 兼容性差。。

## 2.fetch

- fetch里的无论返回什么状态码，都代表成功，只要服务器有响应。
- 服务器没有任何响应，比如断网会失败。

```js
fetch(url,{
    method:'GET',
    headers:{
        'x-token':'xxx'
    }
}).then(res=>{
    if(res.status>=300){
        switch(res.status){
                case 400
                ....
        }
    }
    return res.json()
}).then(res=>{
    console.log(res)
})

fetch(url,{
    method:'POST',
    headers:{
        'x-token':'xxx',
        'Content-Type':'application/x-www-form-urlplant'
    },
    body:'x=0&c=1'
}).then(res=>{
    return res.json()
}).then(res=>{
    console.log(res)
})
```

## 3.跨域

- jsonp
- cors:跨域资源共享，浏览器和服务器之间有安全限制，默认不允许跨域请求，但是我们可以绕过安全限制，服务器里允许指定源可以向当前服务器发请求
- proxy

cors:

- 客户端基于CORS跨域时，首先会先发送一个试探请求options验证是否连接成功。

```js
//使用*不能传输cookie等。

//单一源：可以允许携带资源凭证 Access-Control-Allow-Credentials:true

//fetch需要额外设置
fetch(url,{
    //include 跨域时允许携带
    credentials:'same-origin'//同源才能携带凭证  
})
a2
```

proxy代理

- 向本地的一个服务器发起请求，由本地服务帮我们代理到真实服务器，服务器和服务器之间数据交互不存在跨域。浏览器和本地服务器没有跨域

- 生产环境下
  - 直接修改ngix三行配置
  - 或者iis

jsonp

- 只能支持get请求。

  ```html
  <script>
  	function fn(res){
          console.log(res)
      }
  </script>
  <script>
  	fn({name:'zs',age:18})
  </script>
  ```

  

  

## promise常用api

- Promise.prototype.then() then里的函数return出的东西就是下一个promise接收的。

- Promise.prototype.catch **catch可以捕获他之前的所有promise的错误。**

- Promise.prototype.finally  **es9,不管结果如何都会执行，本质是then方法的特例**

  ```js
  promise.finally(() => {});// 等同于
  promise.then(result =>{return result;},error =>{ throw error;});
  ```

- Promise.all([p1,p2,p3])  **接收一个具有Interator接口的参数。如果全部成功，会返回一个返回结果组成的数组，**

  ```js
  var promise1 = Promise.resolve(3);var promise2 = 42;
  var promise3 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 100, 'foo');
  });
  Promise.all([promise1, promise2, promise3]).then(function(values) {
    console.log(values);
  });
  // expected output: Array [3, 42, "foo"]
  ```

  

## promise常见问题

1. 如何改变promise状态？

   - resolve(value):如果当前是pending就变成resolved状态

   - reject(val):如果当前是pending就变为rejected

   - 抛出异常：如果当前是pending就变为rejected

     ```js
     new Promise(res,rej=>{
       throw new Error('出错')
     })
     ```

2. 一个promise指定多个成功/失败回调函数, 都会调用吗?

   - 当promise改变为对应状态时都会调用

     ```js
     let a = new Promise()
     a.then(...)
     a.then(...)
     ```

## promise并发限制

