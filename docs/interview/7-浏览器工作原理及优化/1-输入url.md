# 输入一个url后，发送了什么？

# 一、导航流程

## 1.用户输入

用户输入关键字时，地址栏会判断输入的是搜索内容还是请求的url

- 如果是搜索内容，地址栏就会使用默认浏览器搜索引擎，来合成带来搜索关键字的URL
- 如果判断输入内容符合URL规则，比如输入的是www.baidu.com。地址栏就会根据规则，加上协议合成完整的url,如https://www.baidu.com

当回车按下后，浏览器页面图片进入加载状态，但是页面并未被替换，需要等待提交文档阶段。

## 2.URL请求过程

### 浏览器端发起 HTTP 请求流程

#### 查询缓存

接下来进入页面资源请求过程。浏览器进程通过IPC（进程间通讯）把URL请求发送到网络进程。

- 网络进程会查找本地缓存是否缓存了该资源 

  - 如果资源未缓存，发起新请求

  - 如果已缓存，检验是否满足条件，条件满足就提供给客户端，否则与服务器进行验证。

  - 检验新鲜通常有两个HTTP头进行控制

    ```
    Expires
    ```

    和

    ```
    Cache-Control
    ```

    ： 

    - HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
    - HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间

- 缓存查找失败，就会进入网络请求过程。

#### 准备IP地址和端口-DNS解析

浏览器使用**HTTP 协议作为应用层协议**，用来封装请求的文本信息；并使用**TCP/IP 作传输层协议**将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说**HTTP 的内容是通过 TCP 的传输数据阶段来实现的**。而tcp连接的第一步是准备ip地址和端口号。因此浏览器会请求DNS返回域名对应的IP,并且提供了DNS数据缓存服务。端口号http默认80

1. 浏览器缓存
2. 本机缓存
3. hosts文件
4. 路由器缓存
5. ISP DNS缓存
6. DNS递归查询（可能存在负载均衡导致每次IP不一样）
7. .....本地---》根---》顶级---》权威（递归或者迭代）

#### TCP连接

- TCP请求

  - 等待TCP队列，Chrome同一个域名同时最多只能建立 6 个 TCP 连接

  - 建立TCP连接 三次握手目的：浏览器和客户端都需要知道自己能正常收发信息。

    - 大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。

    - 客户端发送SYN包=1请求建立连接，Seq=X 我当前序列号,

    - 服务器返回SYN包=1请求建立连接，ack=X+1期望序列号，Seq=Y服务器当前序列号，ACK = 1确认序号成立

    - 客户端发送ack=Y+1期望序列号，seq =X+1，ACK=1 确认洗好成立

      ```
      ACK 0 确认序号无效 1  确认序号成立（请求建立连接）
      SYN 1 new connection 建立连接
      FIN 1 close 关闭连接
      RST 1 distory connection 当前连接异常
      PSH 1 数据无需缓存直接给进程
      URG 0 紧急指针无效 1 禁忌之中有效，这个包不需要排队，直接进入缓存
      复制代码
      ```

- 进入传输数据阶段

#### 发送http请求

浏览器构建**请求行**信息（如下所示），构建好后，浏览器准备发起网络请求。

```
GET /index.html HTTP1.1
复制代码
```

首先浏览器会向服务器发送**请求行**，它包括了**请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议**。

- get请求：直接在浏览器地址栏键入极客时间的域名（time.geekbang.org），这就是告诉服务器要 Get 它的首页资源。
- post请求：它用于发送一些数据给服务器，比如登录一个网站，就需要通过 POST 方法把用户信息发送给服务器。如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过**请求体**来发送。

在浏览器发送请求行命令之后，还要以**请求头**形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。

### 服务器处理请求返回给浏览器

#### 1.返回请求

服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。

通过工具软件 curl 来查看返回请求数据

```
curl -i  https://www.baidu.com/
复制代码
```



![1584414541950](./)



首先服务器会返回**响应行**，包括协议版本和状态码。

- 最常用的状态码是 200，表示处理成功；
- 如果没有找到页面，则会返回**404**。

之后服务器也会随同响应向浏览器发送**响应头**。。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。

最后，服务器发送响应体的数据，通常包含HTML实体内容

##### 2.重定向

如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL,网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。

```
HTTP1.1 301 Moved Permanently (转移 永久地)    响应行

Date:Thu,09 Jan 2020 00:10:33 GMT				响应头
Content-Type:text/html
Content-Length:178
Connection:keep-alive
Location:https://www.czw.com/            ------->loaction字段
Strict-Transport-Security:max-age=15768000
复制代码
```

**在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求**。

##### 3.断开连接

通常服务器返回数据完毕就断开连接，但是如果头信息中有

```
Connection:Keep-Alive 
复制代码
```

则 TCP 连接在发送后将仍然保持打开状态，这样浏览器就能继续通过这个连接发送请求。**省去下次请求建立连接所需要的时间，提升资源加载速度**

如果初始化了一个持久连接，，请求一大堆来自同一个web站点的图片，就可以复用该连接一直请求资源而不是再建立新连接。

##### 4.缓存

当服务器返回**HTTP 响应头**给浏览器时，浏览器是**通过响应头中的 Cache-Control 字段来设置是否缓存该资源**。

我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的

```
Cache-Control:Max-age=2000
复制代码
```

在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。

但如果缓存过期了，浏览器则会继续发起网络请求，并且在**HTTP 请求头**中带上：

```
If-None-Match:"4f80f-13c-3a1xb12a"
复制代码
```

服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。

- 如果没有更新，就返回 304 状态码,告诉浏览器这个缓存可以继续使用
- 如果资源有更新，服务器就直接返回最新资源给浏览器。

这也是很多网页第二次秒开的原因。这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。

##### 5.保持登录状态

简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。

- POST 方法提交用户登录信息给服务器。

- 服务器生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。

  ```
  Set-Cookie: UID=czw1111;
  复制代码
  ```

- 浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把`UID=czw1111`保持到本地。

- 再次访问时，浏览器会在发请求前读取cookie的数据，并把数据写在请求头的cookie里，再把请求头发给浏览器

  ```
  Cookie: UID=czw1111;
  复制代码
  ```

- 服务器查找请求头里面的“Cookie”字段信息，查找到Cookie: UID=czw1111;，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。

- 浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息

#### 2.响应类型处理

接收到后首先进行gzip解压缩，然后判断类型

浏览器如何区分响应的数据类型？

**HTTP中的Content-Type 告诉浏览器服务器返回的响应体数据是什么类型**，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。

```
C:\Users\xxx>curl -i  https://www.baidu.com/
HTTP/1.1 200 OK
Accept-Ranges: bytes
Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
Connection: keep-alive
Content-Length: 2443
Content-Type: text/html
Date: Tue, 17 Mar 2020 03:08:11 GMT
Etag: "588603eb-98b"
Last-Modified: Mon, 23 Jan 2017 13:23:55 GMT
Pragma: no-cache
Server: bfe/1.0.8.18
Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/
复制代码
```

Content-Type 的值是 application/octet-stream，显示数据是**字节流类型**的，通常情况下，浏览器会按照**下载类型**来处理该请求。

Content-type 字段的值是 text/html，这就是告诉浏览器，服务器返回的数据是**HTML 格式**。

如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。

如果 Content-Type 字段的值被浏览器判断为**下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束**。但如果是**HTML，那么浏览器则会继续进行导航流程**。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。

## 3. 准备渲染进程

通常，打开一个新页面就会配套创建一个新的渲染进程。

但是同一站点下会在同一个渲染进程，例如下面的b站，这两个页面使用了一个进程ID；

因为协议都是 HTTPS，而且根域名也都是 bilibili.com。



![1584417667294](./)





![1584417561164](./)



**如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程**。

这个默认策略叫 process-per-site-instance。

如果从b站打开的页面是其他站点，比如从b站打开个学日语的广告，他们则是两个进程，进程id也会不同。



![1584417750659](./)



总结来说，打开一个新页面采用的**渲染进程策略**

- 打开新的页面都会使用单独的渲染进程；
- 如果从 A 页面打开 B 页面，且 A 和 B 都属于**同一站点**的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

## 4. 提交文档(响应体数据)

- 浏览器进程发起“提交文档”的消息，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“**管道**”。
- 等文档数据传输完成之后，渲染进程会返回“**确认提交**”的消息给浏览器进程。
- 浏览器进程在收到“确认提交”的消息后，会**更新浏览器界面状态**，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。



![1584417964645](./)



之后就要进入渲染阶段了。

## 5. 渲染阶段

一旦文档被提交，渲染进程便开始页面解析和子资源加载了，关于这个阶段的完整过程，我会在下一篇文章中来专门介绍。这里你只需要先了解一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。

# 二、渲染流程

渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做**渲染流水线**，其大致流程如下图所示：



![1584421712604](./)



按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。内容比较多，我会用两篇文章来为你详细讲解这各个子阶段。接下来，在介绍每个阶段的过程中，你应该重点关注以下三点内容：

- 开始每个子阶段都有其**输入的内容**；
- 然后每个子阶段有其**处理过程**；
- 最终每个子阶段会生成**输出内容**。

理解了这三部分内容，能让你更加清晰地理解每个子阶段。

## 1.构建 DOM 树

浏览器无法直接使用HTML，需要把HTML转化为浏览器可以理解的DOM树结构。

DOM树构建过程：



![1584421994069](./)



构建 DOM 树的**输入内容**是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。

在控制台输入document就可查看DOM树结构

和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。

```
document.getElementsByTagName("p")[0].innerText = "black"  修改DOM树内容
复制代码
```

DOM树构建完毕后就进入节点样式计算

## 2.样式计算

样式计算（Recalculate Style）目的是为了计算出 DOM 节点中每个元素的具体样式

### 1.把 CSS 转换为浏览器能够理解的结构

CSS 样式来源主要有三种：

- 通过 link 引用的外部 CSS 文件
- `<style>`标记内的 CSS
- 元素的 style 属性内嵌的 CSS

浏览器无法直接理解纯文本css,所以**当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets**。并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。

控制台输入

```
document.styleSheets 
复制代码
```

这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。

### 2. 转换样式表中的属性值，使其标准化

CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以**需要将所有值转换为渲染引擎容易理解的、标准化的计算值**

比如2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700等等。

### 3. 计算出 DOM 树中每个节点的具体样式

**这就涉及到 CSS 的继承规则和层叠规则(权重值，是否脱离文档流，z-index等等)了。**

**CSS 继承就是每个 DOM 节点都包含有父节点的样式**。

比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。

Chrome 的“开发者工具”，选择第一个“element”标签，再选择“style”子标签



![1584422506173](./)

样式计算过程中，会根据 DOM 节点的继承关系来合理计算节点样式。



样式计算过程中的第二个规则是样式层叠，**层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点**

样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。



![1584422641755](./)



**css加载会阻塞DOM树的解析和渲染吗？**

\1. css加载不会阻塞DOM树的解析

\2. css加载会阻塞DOM树的渲染

\3. css加载会阻塞后面js语句的执行，因此会阻塞

**提高css加载速度**

1.使用CDN

2.对css进行压缩

3.合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的

4.减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式，内联样式(把css代码直接写在现有的HTML标签中)的一个缺点就是不能缓存。

## 3.布局阶段

**计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局**。

### 1. 创建布局树

**只包含可见元素布局树**。

- 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；
- 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。

### 2. 布局计算

在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

## 4.分层

**元素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。**

### 什么是分层

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树**（LayerTree）。

Chrome 的“开发者工具”，选择“Layers”

渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面

**浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面**。



![1584423442613](./)





![1584423461312](./)



**通常并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层**。

如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。

### 创建新层的条件

**第一点，拥有层叠上下文属性的元素会被提升为单独的一层。**

层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上



![1584423715992](./)



[层叠上下文属性--MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)。

**第二点，需要剪裁（clip）的地方也会被创建为图层。**

div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁



![1584423950160](./)



```
<style>
      div {
            width: 200;
            height: 200;
            overflow:auto;
            background: gray;
        } 
</style>
<body>
    <div >
        <p> 所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：</p>
        <p> 从上图我们可以看到，document 层上有 A 和 B 层，而 B 层之上又有两个图层。这些图层组织在一起也是一颗树状结构。</p>
        <p> 图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。</p> 
    </div>
</body>
复制代码
```

[overflow-MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow)

此时,渲染引擎会为文字部分单独创建一个层,如果出现滚动条，滚动条也会被提升为单独的层

## 5.图层绘制

完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制,

渲染引擎把一个图层的绘制拆分成很多小的**绘制指令**,再把这些指令按照顺序组成一个待绘制列表



![1584424164974](./)



绘制列表的指令其实非常简单,就是执行一个简单的绘制操作,，比如绘制粉色矩形或者黑色的线等。

绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。

