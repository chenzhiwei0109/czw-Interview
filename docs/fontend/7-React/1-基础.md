# react基础

笔记为本人学习总结，直接从脚手架开始。

## cra起步

```
npx create-react-app 1-my-app
npm start
```

文件结构

```
── README.md ⽂档
├── public 静态资源
│ ├── favicon.ico
│ ├── index.html
│ └── manifest.json
└── src 源码
     ├── App.css
     ├── App.js 根组件
     ├── App.test.js
     ├── index.css 全局样式
     ├── index.js ⼊⼝⽂件
     ├── logo.svg
     └── serviceWorker.js pwa⽀持
├── package.json npm 依赖
```

## React和ReactDom

删除src下⾯所有代码，新建index.js。

```js
import React from 'react';
import ReactDOM from 'react-dom';
// 这⾥怎么没有出现React字眼？
// JSX => React.createElement(...)
ReactDOM.render(<h1>Hello React</h1>, document.querySelector('#root'));
```

React负责逻辑控制，数据 -> VDOM 

ReactDom渲染实际DOM，VDOM -> DOM 

React使⽤JSX来描述UI 

babel-loader把JSX 编译成相应的 JS 对象，React.createElement再把这个JS对象构造成React需 要的虚拟dom。

## JSX

基本用法

```jsx
const name = "react study";
const jsx = <div>hello, {name}</div>;
```

函数

```js
const obj = {
    fistName: "Harry",
    lastName: "Potter"
};
function formatName(name) {
    return name.fistName + " " + name.lastName;
}
const jsx = <div>{formatName(user)}</div>;
```

jsx

```js
const greet = <div>good</div>;
const jsx = <div>{greet}</div>;
```

条件语句

```jsx
const show = true;//false;
const greet = <div>good</div>;
const jsx = (
    <div>
        {/* 条件语句 */}
        {show ? greet : "登录"}
        {show && greet}
    </div>
);
```

数组

```jsx
const arr = ["数组1", "数组2"];
const jsx = (
    <div>
        {/* eslint-disable-next-line */}
        {/* diff 先比较type，然后比较key,所以同类型元素，key必须唯一，否则undefined的化都变成了undefined*/}
        {arr.map((item) => (
            <div key={item}>{item}</div>
        ))}

    </div>
);
```

属性

```jsx
import logo from "./logo.svg";
const jsx = (
    <div>
        {/* 属性：静态值⽤双引号，动态值⽤花括号；class、for等要特殊处理。 */}
        <img src={logo} style={{ width: 100 }} className="img" />
    </div>
);
```

模块化

```css
//创建i.module.scss
.app {
    .logo {
        width: 100px;
    }
}
```

```jsx
import style from "./index.module.scss";
<img className={style.logo} />
```

## 组件

它接受任意的⼊参（即 “props”），并返回⽤于描述⻚⾯展示 内容的 React 元素。

组件有两种形式：class组件和function组件，在hooks之前使用function组件做渲染显示

### 有状态组件rcc

reactClassComponent

```js
//rcc简写
import React, { Component } from "react";
export default class ClassComponent extends Component {
    constructor(props) {
        super(props);
        // state存储状态
        this.state = {
            date: new Date(),
        };
    }

    // mounted。
    componentDidMount(){
        this.timer = setInterval(()=>{
            // 需要使用setState更新状态
            this.setState({
                date:new Date()
            })
        },1000)
    }

    render() {
        const { date } = this.state;
        return (
            <div style={{border:'1px solid'}}>
            <h1>有状态组件</h1>
<p>{date.toLocaleTimeString()}</p>
</div>
);
}
}

```

### 无状态组件rfc

reactFunctionComponent

- useEffect相当于`mounted` 和 `beforeDestoryed`,如果没有写第二个依赖项，他就相当于`update`

```jsx
import React, { useState, useEffect } from "react";

const FuncComponent = (props) => {
    const [date, setDate] = useState(new Date());

    //等渲染完成再执行
    //副作用 useEffect(cb,[]),不能让timer一直执行赋值操作。添加一个依赖项[],这样谁的值改变都不会重新执行
    useEffect(() => {
        const timer = setInterval(() => {
            setDate(new Date());
        }, 1000);
		//组件销毁后清除
        return () => clearInterval(timer);
    }, []);
    return (
        <div>
            <h1>无状态组件RFC reactFunctionComponent</h1>
            <p>{date.toLocaleTimeString()}</p>
        </div>
    );
};

export default FuncComponent;

```

## setState

`setState(partialState, callback)`

- ` partialState `: `object|function`

  ⽤于产⽣与当前state合并的⼦集。

- `callback `:` function`

  state更新之后被调⽤。

### 关于 setState() 有三件事是你应该知道的

- 不要直接修改state
- state的更新可能是异步的
- state的更新会被合并

### 不要直接修改State

```js
this.state.comment = 'Hello';
```

上述代码并不会重新渲染组件，需要使用this.setState()代替：

```css
this.setState({comment: 'Hello'});
```

需要注意的是**唯一可以分配 `this.state` 的地方是构造函数**。

### state(状态) 更新可能是异步的

setState在合成事件里是异步的，因为频繁DOM更新会影响性能所以会把所有更新进行批量更新，

React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。
 因为`this.props`和`this.state` 可能是异步更新的，你不能依赖他们的值计算下一个`state`(状态)。以下面的代码为例:

```kotlin
this.setState({
  counter: this.state.counter + 1
});
```

我们并不能通过上述代码得到想要的值，为了弥补这个问题，使用另一种 setState() 的形式，接受一个函数。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数，代码如下：

```jsx
this.setState((prevState, props) => ({
  counter: prevState.counter + 1
}));
```

或者在回调中获取状态值

```js
this.setState({counter: this.state.counter +1},
    () => {
        console.log("counter", this.state.counter);
    }
);
```

或者使用定时器

```js
setTimeout(() => {
    this.setCounter();
}, 0);
```

原生事件修改状态

```js
changeValue = v => {
    this.setState({
        counter: this.state.counter + 1
    });
};
componentDidMount(){
    document.body.addEventListener('click', this.changeValue, false)
}
```

### state(状态)更新会被合并

```js
changeValue = v => {
    this.setState({
        counter: this.state.counter + v
    });
};
setCounter = () => {
    this.changeValue(1);
    this.changeValue(2);
};
```

如果想要链式更新state：

```js
changeValue = v => {
    this.setState(state => ({ counter: state.counter + v }));
};
setCounter = () => {
    this.changeValue(1);
    this.changeValue(2);
};
```

## 使用 PropTypes 进行类型检查

<https://react.docschina.org/docs/typechecking-with-proptypes.html>

- defaultProps默认值，父组件未传时.

```js
import PropTypes from 'prop-types'
//child
class TodoItem extends React.Component {  
    //内部声明静态检查
    static defaultProps ={
        test:'hello world'  
    }
}
TodoItem.PropTypes = {
    content:ProTypes.string.isRequired，//必须
    deleteItem:PropTypes.func, //函数类型
    index:PropTypes.number //数字类型
}
TodoItem.defaultProps = {
    test:'hello world',
}
```

## 生命周期

- 获取默认的props
- 获取state
- 

![img](../../.vuepress/public/assets/img/16775500-8d325f8093591c76.jpg)

