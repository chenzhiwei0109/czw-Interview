# 笔试题2

## 头条-Promise并发数限制

- promise.all会并发执行所有promise

- 我们想控制**同一时刻只执行两个promise**,有一个promise空下来再执行下一个promise。

请实现如下需求:

```js
class Scheduler {
    add(promiseCreator) {
    }
}

const timeout = time => new Promise(resolve => setTimeout(resolve, time))

const scheduler = new Scheduler()

const addTask = (time, order) => {
    scheduler.add(() => timeout(time).then(() => console.log(order)))
}

addTask(1000, 1)
addTask(500, 2)
addTask(300, 3)
scheduler.start();
```



题目解释：

```js
//timeout函数返回一个promise实例，通过传递的time参数控制执行时间来模拟并发
const timeout = time => new Promise(resolve => setTimeout(resolve, time))

//创建并发控制实例
const scheduler = new Scheduler()
const addTask = (time, order) => {
    scheduler.add(() => timeout(time).then(() => console.log(order)))
}

//添加任务，第一个1000ms后执行，第二个500ms后执行，第三个300ms后执行。
//此时执行顺序应该是 2 3 1 因为2执行500ms完毕后执行3,3执行完毕后1并没有执行完毕。
addTask(1000, 1)
addTask(500, 2)
addTask(300, 3)
```

解答

```js
class Scheduler {
    constructor(){
        this.list = [];
        this.maxNum = 2;
        this.workingNum = 0
    }
    add(promiseCreator) {
        this.list.push(promiseCreator)
    }
    start(){
        for(var i=0;i<this.maxNum;i++){
            this.doNext()
        }
    }
    doNext(){
        if(this.list.length&&this.workingNum<this.maxNum){
                    // 正在执行的任务数+1

            this.workingNum++;
            this.list.shift()().then(res => {
                // 完成后，正在执行的任务数减1
                // 然后继续执行下一步此任务。
                this.workingNum--;
                this.doNext()
            })
        }
    }
}

const timeout = time => new Promise(resolve => setTimeout(resolve, time))

const scheduler = new Scheduler()

const addTask = (time, order) => {
    scheduler.add(() => timeout(time).then(() => console.log(order)))
}

addTask(1000, 1)
addTask(500, 2)
addTask(300, 3)
scheduler.start();
```

## 头条:异步串行 | 异步并行

```js
// 字节面试题，实现一个异步加法
function asyncAdd(a, b, callback) {
    setTimeout(function() {
        callback(null, a + b);
    }, 500);
}

// 解决方案
// 1. promisify
const promiseAdd = (a, b) => new Promise((resolve, reject) => {
    asyncAdd(a, b, (err, res) => {
        if (err) {
            reject(err)
        } else {
            resolve(res)
        }
    })
})

// 2. 串行处理
async function serialSum(...args) {
    return args.reduce((task, now) => task.then(res => promiseAdd(res, now)), Promise.resolve(0))
}

// 3. 并行处理
async function parallelSum(...args) {
    if (args.length === 1) return args[0]
    const tasks = []
    for (let i = 0; i < args.length; i += 2) {
        tasks.push(promiseAdd(args[i], args[i + 1] || 0))
    }
    const results = await Promise.all(tasks)
    return parallelSum(...results)
}

// 测试
(async() => {
    console.log('Running...');
    const res1 = await serialSum(1, 2, 3, 4, 5, 8, 9, 10, 11, 12)
    console.log(res1)
    const res2 = await parallelSum(1, 2, 3, 4, 5, 8, 9, 10, 11, 12)
    console.log(res2)
    console.log('Done');
})()
```





