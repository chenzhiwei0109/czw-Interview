# 路由

## 动态路由匹配

我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对 于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中 使用“动态路径参数”(dynamic segment) 来达到这个效果：

```js
{
    path: '/course/:name',
    component: () => import('../views/Detail.vue')
}

```

```html
<router-link :to="`/course/${c.name}`">
    {{ c.name }} - {{ c.price | currency('￥') }}
</router-link>
```

```html
<div>
    <h2>detail page</h2>
    <p>{{$route.params.name}} ...</p>
</div>

```

### 通配符

```js
{
    // 会匹配所有路径
    path: '*',
     component: () => import('../views/404.vue')
}

```

## 嵌套路由

```js
const routes = [{
    path: '/about',
    name: 'about',
    component: () =>import ('../views/About.vue'),
    children: [{
        path: ':name',
        component: () =>import ('../views/Detail.vue')
    }]
}]
```

## 响应路由参数变化

```js
export default {
    watch: {
        $route: {
            handler: () => {
                console.log("$route change");
            },
            immediate: true
        }
    }
};

```

## 编程导航

```js
// 字符串
router.push('home')
// 对象
router.push({ path: 'home' })
// 命名的路由
router.push({ name: 'user', params: { userId: '123' }})
// 带查询参数，变成 /register?plan=private
router.push({ path: 'register', query: { plan: 'private' }})

```

## 命名路由

通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。 你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。

```js
const router = new VueRouter({
    routes: [
        {
            path: '/user/:userId',
            name: 'user',
            component: User
        }
    ]
})

```

要链接到一个命名路由，可以给 router-link 的 to 属性传一个对象：

```html
<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>
```

调用 router.push() 时：

```html
router.push({ name: 'user', params: { userId: 123 }})
```

路由守卫

## 进阶

### 导航守卫

```js
router.beforeEach((to, from, next) => {})//全局前置
router.beforeResolve((to, from, next) => {})//导航被确认前，组件内守卫和异步路由组件被解析之后
router.afterEach((to, from) => {})//全局后置
routes: [//路由独享
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
      }
    }
]

beforeRouteEnter  //组件实例未创建，无this
beforeRouteUpdate (2.2 新增) //组件复用
beforeRouteLeave
```

#### 导航流程

```
导航被触发。
在失活的组件里调用 beforeRouteLeave 守卫。
调用全局的 beforeEach 守卫。
在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
在路由配置里调用 beforeEnter。
解析异步路由组件。
在被激活的组件里调用 beforeRouteEnter。
调用全局的 beforeResolve 守卫 (2.5+)。
导航被确认。
调用全局的 afterEach 钩子。
触发 DOM 更新。
调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。
```

#### 全局守卫

```js
router.beforeEach((to, from, next) => {

}
```

```js
const routes = [
    {
        path: '/about',
        meta: {
            auth: true
        }
    },
    {
        path: '/login',
        component: () => import('../views/Login.vue')
    },
]
router.beforeEach((to, from, next) => {
    if (to.meta.auth) {
        if (window.isLogin) {
            next()
        } else {
            next('/login?redirect='+to.fullPath)
        }
    } else {
        next()
    }
})

```

```js
login() {
	window.isLogin = true
	this.$router.push(this.$route.query.redirect)
},
logout() {
	window.isLogin = false
}

```

### 数据获取

路由激活时，获取数据的时机有两个：

- **导航完成之后获取**：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。

  ```js
  export default = {
      created () {
          this.fetchData()
      },
      watch: {
          '$route': 'fetchData'
      }
  
  }
  ```

  

- **导航完成之前获取**：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航

  ```js
  export default = {
      // 组件未渲染，通过给next传递回调访问组件实例
      beforeRouteEnter (to, from, next) {
          getPost(to.params.id, post => {
              next(vm => vm.setData(post))
          })
      },
      // 组件已渲染，可以访问this直接赋值
      beforeRouteUpdate (to, from, next) {
          this.post = null
          getPost(to.params.id, post => {
              this.setData(post)
              next()
          })
      },
  
  }
  ```

### 动态路由

通过router.addRoutes(routes)方式动态添加路由

### 懒加载

### keep-alive

```
<keep-alive include="about">
<router-view></router-view>
</keep-alive
```

使用include或exclude时要给组件设置name

 两个特别的生命周期：activated、deactivated