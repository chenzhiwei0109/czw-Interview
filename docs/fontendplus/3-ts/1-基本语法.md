# 基本语法

## 类型注解和类型检测

**类型注解**

```typescript
let a:string;
a = '你好'//正确
a = 2 //错误
```

编译器可以通过类型推断省略这个语法

```typescript
let a = '你好' 
```

## 函数类型

必填参：参数一旦声明，就要求传递，且类型需符合

可选值：可以不传

默认值：返回类型

```typescript
//函数类型注解 返回值要是number类型
function add(first:number,second:number,msg?: string):number{
  return first+second;
}

//函数可以没有返回值
function warn():void{
    
}
function fn2(o:{prop:number})
```

函数重载

```typescript
// 重载1 传入回调，没有返回值
function watch(cb1: () => void): void;
// 重载2 
function watch(cb1: () => void, cb2: (v1: any, v2: any) => void): void;
// 实现
function watch(cb1: () => void, cb2?: (v1: any, v2: any) => void) {
    if (cb1 && cb2) {
        console.log('执行watch重载2');
    } else {
        console.log('执行watch重载1');
    }
}
```

## **数组**

```typescript
//类型数组
let arr: string[];////必须存储string
arr = ['你好']
const strArr:string[] = ['a','b','c'];

//自定义参数
const arr:(number | string)[] = [1,'2',3]
```

## type别名和interface接口

```js
type User = {name:string,age:number}
function fn3(o:User){}
const objectArr:User[]={
  {name:'czw',age:23}
}
class Teacher{
  name:string,
  age:number;
}
const objectArr:Teacher[]={
  new Teacher(),
	{
    name:'czw',
    age:18
  }
}
```

interface和type有区别的，能用接口表示就用interface.interface不能是基本类型

```ts
interface Person{
  name:string;
}
type Person{
	name:string
}
type Person = string
```

字面量形式传入是强校验

```ts
getA({x:1,y:2})//错
const a = {x:1,y:2};
getA(a) //对 ；这样就不是强校验，y可以传入
```

```ts
interface Person{
  name:string;
  age?:number; //age可有可无
  readonly sex:string;  //只读
  [propName:string]:any //多出其他属性时，也可以
  say():string; //方法返回string
}

//类使用接口
class User implements Person { //User类应用这个Person接口
  name = 'ss'
  say(){
    return 'sss'
  }
}
```

```ts
interface SS {
  
}
```

## 类型相关

**类型断言**

某些情况下用户会比编译器更确定某个变量的具体类型，可用类型断言as

```js
const someValue: any = "this is a string";
const strLength = (someValue as string).length;
```

通常类型断言会将一种更范的类型断言为更具体的类型

**联合类型**

希望某个变量或参数的类型是多种类型其中之一

```js
let union: string | number;
union = '1'; // ok
union = 1; // ok

```

**交叉类型**

想要定义某种由多种类型合并而成的类型使用交叉类型

```typescript
type First = {first: number};
type Second = {second: number};
type FirstAndSecond = First & Second;
function fn3(param: FirstAndSecond): FirstAndSecond {
    return {first:1, second:2}
}
```

## class类

ts中的类和es6中大体相同，这里重点关注ts带来的访问控制等特性

```typescript
class Parent {
    private _foo = "foo"; // 私有属性,相当于构造函数内部var声明的
    protected bar = "bar"; // 保护属性，可以在子类中访问
    // 参数属性：构造函数参数加修饰符，能够定义为成员属性
    constructor(public tua = "tua") {}
    // 方法也有修饰符
    private someMethod() {}
    // 存取器：属性方式访问，可添加额外逻辑，控制读写性
    get foo() {
        return this._foo;
    }
    set foo(val) {
        this._foo = val;
    }
}
const P = new Parent() // 只能看到tua 和 foo。

```

```vue
<template>
<li>特性数量：{{count}}</li>
</template>
<script lang="ts">
    export default class HelloWorld extends Vue {
        // 定义getter作为计算属性,只读
        get count() {
            return this.features.length;
        }
    }
</script>
```

## 泛型

泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定 类型的一种特性。以此增加代码通用性。

```typescript
// 不用泛型
// interface Result {
// ok: 0 | 1;
// data: Feature[];
// }
// 使用泛型
interface Result<T> {
    ok: 0 | 1;
    data: T; //T是动态类型
}
// 泛型方法
function getResult<T>(data: T): Result<T> {
    return {ok:1, data};
}
// 用尖括号方式指定T为string
getResult<string>('hello')
// 用类型推断指定T为number
getResult(1)

```



